= Библиотека K3DM
Tepex <tepex@mail.ru>
1.0, 15/VI-2025
:source-highliter: rouge
:toc:
:toc-title: Содержание

K3DM (Kotlin DDD Model) — библиотека базовых типов, предназначенная для построения <<domain-model,моделей предметных областей>> на языке Котлин согласно с тактическими _DDD_-патернами — _Entity_ и _Value Object_. Состоит из конечной (закрытой) <<fst,*ФСТ*>>, аннотаций // и регламента построения <<cdt,*CDT*>>.

== Workflow
link:.github/workflows/pr-check.yml[Проверка сборки (build & test)] для обычных _PR_, чтобы гарантировать работоспособность кода до его попадания в `dev`.

link:.github/workflows/release-modules.yml[_Release Please_ workflow]:

. Вы пушите в `dev`: обычный комит вида `feat(fts): add core logic`.
. `release-please` (Шаг 1): Видит новый комит, создает новый _PR_ (или обновляет существующий), который содержит:
.. Обновленный `.release-please-manifest.json` с версией `1.1.0`.
.. Обновленный `fts/CHANGELOG.md`.
. Вы мержите этот _PR_: После проверки вы нажимаете "Merge".
. `release-please` (Шаг 2): Снова запускается по пушу в `dev`. Понимает, что это мерж его собственного _PR_, создает _GitHub Release_ и _Git Tag_ (fts-v1.1.0).
. `publish`: Видит флаг `releases_created: true`, считывает обновленный манифест через Gradle и отправляет артефакт в _Maven Central_.
. `smoke-test`: После публикации запускает тесты, которые проверяют, что опубликованная версия доступна в _Maven Central_ и может быть использована в проекте.
. `sync-to-main`: После успеха `publish`, скрипт берет актуальное состояние `dev` (уже с новыми версиями и `CHANGELOG`) и переносит его в `main`.
. Игнорирование пустых релизов: Если вы замержите коммит без _scope_ или просто `docs:`, _Release Please_ не создаст _PR_ и публикация не запустится.


== Установка
image:https://img.shields.io/maven-central/v/ru.it-arch/k3dm[Maven Central Version]

[source,kotlin]
----
dependencies {
    implementation("ru.it-arch:k3dm:<latest_version>")
}
----
// release: ./gradlew publishAndReleaseToMavenCentral --no-configuration-cache

== Функциональные требования

=== Конечность
Количество возможных вариантов типов ограничено.

=== Валидируемость
Наличие механизма валидации при создании объекта заданного типа. Проверка входных параметров, из которых конструируется объект, на предмет допустимых значений.

=== Value Object
Предполагает свою иммутабельность. Однако, для операций над типами необходим механизм изменения свойств типа. _Entity_ пре

== Мотивация
[quote,Закон Е. А. Седова]
В сложной иерархически организованной системе рост разнообразия на верхнем уровне обеспечивается ограничением разнообразия на предыдущих уровнях, и наоборот, рост разнообразия на нижнем уровне разрушает верхний уровень организации (то есть, система как таковая гибнет).

Котлин является языком программирования общего назначения, предоставляющий очень широкие возможности для разработчика. В частности, — для проектирования собственных структур данных (типов). К сожалению, такая широта зачастую оборачивается появлением порочных практик, таких как мутабельность публичных свойств, одержимость примитивами (_primitive obsession_), нарушениями принципов _SOLID_ и пр.

При проектировании <<domain-model,*МПО*>> необходимо создать собственную <<fst,*ФСТ*>> с  обусловленными бизнес-требованиями правилами и ограничениями, возможностью валидации объектов при их создании, покрытию юнит-тестами логики <<domain-model,*МПО*>>. В свою очередь такая <<fst,*ФСТ*>> должна создаваться в рамках аксиоматики базовой <<fst,*ФСТ*>> высшего уровня, как основы, и которая бы воплощала концепцию тактических _DDD_-патернов — _Entity_ и _Value Object_.

Ограничения должны применяться на самых ранних этапах. Отчасти это возможно решить на уровне компиляции путем создания контрактов (абстрактых методов) в базовых интерфейсах и проверкой их логики юнит-тестами. Отчасти — наличием регламента, задающим эти ограничения. Проверка соблюдения регламента может осуществляться за счет дополнительных инструментов автоматизации: валидаторы кода, линтеры, кодогенераторы.

== Цель
- Создание закрытой базовой <<fst,*ФСТ*>>, воплощающую концепцию тактических _DDD_-патернов.
- Обеспечение механизма валидации <<cdt,*CDT*>> при создании объектов.
- Создание регламента проектирования <<cdt,*CDT*>>.

[#types]
== Базовая *ФСТ*
Интерфейсы <<kddd,*Fts*>> наследуются от корневого sealed-интерфейса `Fts` который имеет метод `validate()` предназначенный для валидации объектов при их создании. В переопределенных методах `validate()` должна реализовываться логика валидации объекта и выкидываться исключение `IllegalStateException` в рамках этой логики.

=== `IEntity : Fts`
Определяет тактический _DDD_-патерн _Entity_. Содержит поля:

- `id` — идентичность сущности.
- `content` — _Value Object_ содержимого сущности.

<<regulation,*Регламент*>> требует, что реализация этого интерфейса должна переопределять контракт `hashCode()/equals()`, завязав их на поле `id`. Отдельная группировка свойств сущности в свойство `content` обусловлена подходом, обоснованным у https://enterprisecraftsmanship.com/posts/nesting-value-object-inside-entity/[Вдадимира Хорикова].

=== `ValueObject : Fts`
Определяет тактический _DDD_-патерн _Value Object_. Sealed-интерфейс со следующими наследниками:

==== `ValueObject.Data`
Предназначен для проектирования <<cdt,*CDT*>> с несколькими свойствами и последующей имплементации <<cdt,*CDT*>> в виде `data class`. Декларирует метод `<T: Fts, A: Fts> fork(vararg args: A): T` для возможности копирования объекта этого типа и аналогичен методу `copy()` у `data class`. Реализация этого метода описана в <<regulation,*Регламенте*>>.

==== `ValueObject.Value<BOXED: Any>`
Предназначен для проектирования *CDT* с одним свойством и последующей имплементации <<cdt,*CDT*>> в виде `value class`. Тип свойства определяется параметризованным типом `BOXED` и может быть либо <<pt,*ПТ*>>, либо <<ct,*ТОН*>>. Обусловлено борьбой с _одержимостью примитивами_. Декларирует метод `<T : Value<BOXED>> fork(boxed: BOXED): T` для возможности копирования объекта этого типа и аналогичен методу `copy()` у `data class`. Реализация этого метода описана в <<regulation,*Регламенте*>>.

Метод `fork()` в контрактах интерфейсов `ValueObject` призван обеспечить возможность создания функционала/операций над этими типами на этапе декларации интерфейсов и, соответственно, компиляции, что обеспечивает возможность сразу создавать и запускать юнит-тесты с соответств прежде, чем будут .

[#annotations]
== Аннотации
- `Generatable`
- `Parsable`
- `SerialName`
- `Ignore`
- `Neutral`
- `OptIn`

[glossary]
[#domain-model]
== Термины и определения
МПО:: Модель Предметной Области (Domain Model) — совокупность типов данных и их функционала. https://martinfowler.com/eaaCatalog/domainModel.html[Определение по М. Фаулеру].
[#user]
Пользователь:: Разработчик (бизнес-аналитик, архитектор), использующий данную библиотеку для проектирования собственных типов (*CDT*) для некоторого своего домена.
[#fst]
ФСТ:: Формальная система типов, построенная на заданной аксиоматике — постулатах, определяющих допустимые границы значений и операции над типами.
[#pt]
ПТ:: Примитивный тип Котлин: `String`, `Int`, `Boolean`, и т.д.
[#ct]
ТОН:: Тип общего назначения из стандартных пакетов Java и Котлин, не требующих подключения специальных зависимостей: `File`, `UUID`, `URI`, и т.д.
[#kddd]
Fts:: Корневой тип библиотеки `k3dm`.
[#cdt]
CDT:: Customer Domain Type — проектируемый *Пользователем* собственный тип структуры данных.
