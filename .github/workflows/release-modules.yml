name: Release Please System

on:
  push:
    branches:
      - dev

jobs:
  release-please:
    runs-on: ubuntu-latest
    outputs:
      # Эти выходы нужны, чтобы понять, был ли именно факт МЕРЖА релиз-PR
      releases_created: ${{ steps.release.outputs.releases_created }}
      paths_released: ${{ steps.release.outputs.paths_released }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Скачиваем всю историю, чтобы переключаться между ветками

      - uses: googleapis/release-please-action@v4
        id: release
        with:
          # Для создания PR и триггера последующих экшенов лучше использовать PAT
          token: ${{ secrets.MY_RELEASE_PAT }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json
          # Помогает корректно определять компоненты в монорепозитории. Добавляет в релизный тег
          # префикс названия модуля
          # Auto-merge требует, чтобы в настройках репозитория была включена опция "Allow auto-merge" (Settings > General > Pull Requests).
          include-component-in-tag: true

      - name: Update gradle.properties after release
        if: ${{ steps.release.outputs.release_created }}
        run: |
          # Настраиваем конфиг гита внутри раннера
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # 1. Получаем список путей, которые были реально выпущены
          RELEASED_PATHS='${{ steps.release.outputs.paths_released }}'
          
          # 3. Проходим циклом по каждому пути из списка
          echo "$RELEASED_PATHS" | jq -r '.[]' | while read -r path; do
            # Получаем версию для этого пути
            NEW_VERSION=$(jq -r ".\"$path\"" .release-please-manifest.json)
          
            # Логика определения пути
            [ "$path" == "." ] && FILE_PATH="gradle.properties" || FILE_PATH="$path/gradle.properties"
            echo "Checking module: $path, looking for file: $FILE_PATH"
    
            # Обновляем только если файл существует
            if [ -f "$FILE_PATH" ]; then
              echo "File found. Content before sed:"
              grep "^version" "$FILE_PATH" || echo "Version line NOT FOUND in file!"
              sed -i "s/^\(version[[:space:]]*=[[:space:]]*\).*/\1$NEW_VERSION/" "$FILE_PATH"
              echo "Content after sed:"
              grep "^version" "$FILE_PATH"
            else
              echo "Skipping $path: $FILE_PATH not found"
            fi
          done
          
          # Настройка и проверка diff               
          echo "--- Git Status ---"
          git status
               
          echo "--- Git Diff ---"
          git diff

          # 4. Коммитим изменения в ветку PR
          if ! git diff --cached --exit-code; then
            git add "$FILE_PATH"
            git commit -m "chore: update gradle.properties after release [skip ci]"
            git push origin ${{ github.ref_name }}          
          else
            echo "No changes to commit in gradle.properties. Everything is already in sync."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.MY_RELEASE_PAT }}

  publish:
    needs: release-please
    # Запускается только если Release Please создал тег (т.е. PR был замержен)
    if: ${{ needs.release-please.outputs.releases_created == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: Publish Modules
        env:
          ORG_GRADLE_PROJECT_mavenCentralUsername: ${{ secrets.MAVEN_USERNAME }}
          ORG_GRADLE_PROJECT_mavenCentralPassword: ${{ secrets.MAVEN_PASSWORD }}
          ORG_GRADLE_PROJECT_signingInMemoryKey: ${{ secrets.GPG_PRIVATE_KEY }}
          ORG_GRADLE_PROJECT_signingInMemoryKeyPassword: ${{ secrets.GPG_PASSPHRASE }}
          # Превращаем JSON-строку со списком путей в массив для удобства
          PATHS: ${{ needs.release-please.outputs.paths_released }}
        run: |
          # Проверяем, какой модуль был выпущен, и деплоим его
          if [[ $PATHS == *"fts"* ]]; then
            ./gradlew :fts:pTMC
          fi
          
          if [[ $PATHS == *"ksp-processor"* ]]; then
            # ./gradlew :ksp-processor:pTMC
            echo "fake publishing"
          fi

  sync-to-main:
    needs: publish
    runs-on: ubuntu-latest
    if: success() # Выполнить только если публикация прошла успешно
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.MY_RELEASE_PAT }}

      - name: Merge dev into main
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
        
          # Переключаемся на main и вмерживаем dev
          git checkout main
          git merge origin/dev --ff-only || git merge origin/dev --no-ff -m "chore: sync dev to main [skip ci]"
        
          # Пушим изменения в main
          git push origin main
